//! Синтаксис spread і rest

//TODO spread: передача аргументів
// Операція ... (spread) дозволяє розподілити колекцію елементів(масив, рядок або об'єкт) в місце,
// в якому очікується набір окремих значень.Звичайно, існують деякі обмеження, наприклад, не можна розподілити масив в об'єкт і навпаки.

// Можна навести аналогію з ящиком яблук.Поставивши ящик на підлогу, не виймаючи з нього яблука, отримаємо аналог масиву значень.
// Якщо висипати яблука з ящика на підлогу, відбудеться розподіл - набір окремих значень.

// Відмінність лише одна - в JavaScript розподіл не змінює оригінальну колекцію, тобто створюється копія кожного елемента.
// Після розподілу залишиться і ящик повний яблук, і копія кожного яблука на підлозі.

// Наприклад, метод Math.max(аргументи) шукає і повертає найбільший з аргументів (чисел), тобто очікує не масив значень, а довільну кількість аргументів.

// const temps = [14, -4, 25, 8, 11];

// // В консолі буде масив
// console.log(temps);
// // ❌ Так не спрацює, тому що передаємо цілий масив
// console.log(Math.max(temps)); // NaN

// // В консолі буде набір окремих чисел
// console.log(...temps);
// // ✅ Розподілимо колекцію елементів у якості окремих аргументів
// console.log(Math.max(...temps)); // 25

// Тобто запис Math.max(...[14, -4, 25, 8, 11]), після інтерпретації перетворюється у Math.max(14, -4, 25, 8, 11) -
// синтаксис ... повертає розпакований масив, тобто розподіляє його елементи у якості окремих аргументів.

//TODO spread: створення нового масиву
// Операція ... (spread) дозволяє створити копію масиву або «склеїти» довільну кількість масивів в один новий.
// Раніше для цього використовували методи slice() і concat(), але операція розподілу дозволяє зробити те саме у коротшій формі.

// //* EXP 1 - копія масиву
// const temps = [14, -4, 25, 8, 11];

// // Це точна, але незалежна копія масиву temps

// const temps = [14, -4, 25, 8, 11];

// const copyOfTemps = [...temps];
// console.log(copyOfTemps); // [14, -4, 25, 8, 11]

// // По суті це аналог методу [arr].slice()
// const newCopyOfTemps = temps.slice();
// console.log(newCopyOfTemps); // [14, -4, 25, 8, 11]

// //* EXP 2 - сшивання 2х масивів в один
// const lastWeekTemps = [14, 25, 11];
// const currentWeekTemps = [23, 17, 18];

// const allTemps = [...lastWeekTemps, ...currentWeekTemps];
// console.log(allTemps); // [14, 25, 11, 23, 17, 18]

// // По суті це аналог методу [arr1].concat(arr2)
// const allTempsViaConcat = lastWeekTemps.concat(currentWeekTemps);
// console.log(allTempsViaConcat); // [14, 25, 11, 23, 17, 18]

//TODO spread: створення нового об'єкта
// Операція ... (spread) дозволяє розподілити властивості довільної кількості об'єктів в один новий.

//* EXP 1
// const first = { propA: 5, propB: 10 };
// const second = { propC: 15 };
// const third = { ...first, ...second };
// console.log(third); // { propA: 5, propB: 10, propC: 15 }

// По суті це аналог такого запису:
// const fouth = {
//     propA: first.propA,
//     propB: first.propB,
//     propC: second.propC
// }
// console.log(fouth);

// А як воно влаштовано під капотом ?

//* EXP 2
// Порядок розподілу має значення.Імена властивостей об'єкта - унікальні, тому властивості об'єкта,
// що розподіляється, можуть перезаписати значення вже існуючої властивості, якщо їх імена збігаються.
// const first = { propA: 5, propB: 10, propC: 50 };
// const second = { propC: 15, propD: 20 };

// const third = { ...first, ...second };
// console.log(third); // { propA: 5, propB: 10, propC: 15, propD: 20 }

// const fourth = { ...second, ...first };
// console.log(fourth); // { propA: 5, propB: 10, propC: 50, propD: 20 }

//? Під час розподілу можна додавати властивості у довільне місце.
//? Головне пам'ятати про унікальність імені властивості і про те, що її значення може бути перезаписане.
// const first = { propA: 5, propB: 10, propC: 50 };
// const second = { propC: 15 };

// const third = { propB: 20, ...first, ...second };
// console.log(third); // { propA: 5, propB: 10, propC: 15 }

// const fourth = { ...first, ...second, propB: 20 };
// console.log(fourth); // { propA: 5, propB: 20, propC: 15 }

// const fifth = { ...first, propB: 20, ...second };
// console.log(fifth); // { propA: 5, propB: 20, propC: 15 }

//TODO rest: збирання всіх аргументів функції
// Операція ... (rest) дозволяє зібрати групу незалежних елементів у нову колекцію (масив).
// Синтаксично - це близнюк операції розподілу ... (spread), але відрізнити їх просто - розподіл - коли ... знаходиться у правій частині операції присвоювання,
// а збирання - коли ... знаходиться в її лівій частині.

// Повернемось до аналогії з яблуками.Якщо на підлозі лежать яблука і у нас є порожній ящик,
// то операція rest дозволить «зібрати» яблука в ящик. Водночас, оригінальні яблука залишаться на підлозі, а в ящику буде копія кожного яблука.

//? EXP -  Одна зі сфер застосування операції rest - це створення функцій, які можуть приймати будь-яку кількість аргументів.
// Як оголосити параметри функції таким чином,
// щоб можна було передати будь-яку кількість аргументів?
// function multiply() {
//   // ...
// }

// multiply(1, 2);
// multiply(1, 2, 3);
// multiply(1, 2, 3, 4);

// Якщо прибрати увесь «синтаксичний шум» і подивитися на аргументи і параметри функції,
// то аргументи знаходяться у правій частині операції присвоювання, а параметри - у лівій,
// тому що значення аргументів присвоюються оголошеним параметрам. Отже, можна «зібрати» всі аргументи функції в один параметр, використовуючи операцію rest.
// function multiply(...args) {
//   console.log(args); // масив усіх аргументів
// }

// multiply(1, 2); // [ 1, 2 ]
// multiply(1, 2, 3); // [ 1, 2, 3 ]
// multiply(1, 2, 3, 4); // [ 1, 2, 3, 4 ]

// Ім'я параметра може бути довільним. Найчастіше його називають args, restArgs або otherArgs - скорочено від arguments.

//TODO rest: збирання частини аргументів функції
// Операція ... (rest) також дозволяє зібрати в масив тільки ту частину аргументів, яка необхідна, оголосивши параметри до «збирання».
// function multiply(firstNumber, secondNumber, ...otherArgs) {
//   console.log(firstNumber); // Значення першого аргументу
//   console.log(secondNumber); // Значення другого аргументу
//   console.log(otherArgs); // Масив інших аргументів
// }

// multiply(1, 2); // 1 2 []
// multiply(1, 2, 3); // 1 2 [ 3 ]
// multiply(1, 2, 3, 4); // 1 2 [ 3, 4 ]

//! ДИСТРУКТУРИЗАЦІЯ
// Під час розробки програм дані приходять, як правило, у вигляді масивів і об'єктів, значення яких необхідно записати у локальні змінні.
// Для того, щоб робити це максимально просто, в сучасному стандарті існує синтаксис деструктуризованого присвоювання.

//! Диструктцризація об'єктів

// Складні дані завжди представлені об'єктом. Багаторазові звернення до властивостей об'єкта візуально забруднюють код.

// const book = {
//   title: "The Last Kingdom",
//   author: "Bernard Cornwell",
//   genres: ["historical prose", "adventure"],
//   isPublic: true,
//   rating: 8.38,
// };

// const accessType = book.isPublic ? "публічному" : "закритому";
// const message = `Книга ${book.title} автора ${book.author} з рейтингом ${book.rating} знаходиться в ${accessType} доступі.`;

// console.log(message);

// Деструктуризація дозволяє «розпакувати» значення властивостей об'єкта у локальні змінні. Це робить код в місці їх використання менш «шумним».

// const book = {
//   title: "The Last Kingdom",
//   author: "Bernard Cornwell",
//   genres: ["historical prose", "adventure"],
//   isPublic: true,
//   rating: 8.38,
// };

// Деструктуризуємо
// const { title, author, isPublic, rating, coverImage } = book;
// console.log(coverImage); // undefined

// const accessType = isPublic ? "публічному" : "закритому";
// const message = `Книга ${title} автора ${author} з рейтингом ${rating} знаходиться в ${accessType} доступі.`;

// console.log(message);

//? Деструктуризація завжди знаходиться у лівій частині операції присвоєння.Змінним всередині фігурних дужок присвоюються значення властивостей об'єкта.
//? Якщо ім'я змінної та ім'я властивості збігаються, відбувається присвоювання, в іншому випадку, їй буде присвоєно undefined.
//? Порядок оголошення змінних у фігурних дужках - неважливий.

//TODO Значення за замовчуванням
//? Для того, щоб уникнути присвоєння undefined під час деструктуризації неіснуючих властивостей об'єкта,
//? можна задати змінним значення за замовчуванням, які будуть присвоєні лише у тому випадку, якщо об'єкт не містить властивості з таким ім'ям.

// const book = {
//   title: "The Last Kingdom",
//   author: "Bernard Cornwell",
// };

// Додамо зображення обкладинки, якщо воно відсутнє в об'єкті книги
// const {
//   title,
//   coverImage = "https://via.placeholder.com/640/480",
//   author,
// } = book;

// console.log(title); // The Last Kingdom
// console.log(author); // Bernard Cornwell
// console.log(coverImage); // https://via.placeholder.com/640/480

//TODO Зміна імені змінної
//? Під час деструктуризації можна змінити ім'я змінної, в яку розпаковується значення властивості.
//? Спочатку пишемо ім'я властивості, з якої хочемо отримати значення, після чого ставимо двокрапку і пишемо ім'я змінної,
//? в яку необхідно помістити значення цієї властивості.

// const firstBook = {
//   title: "The Last Kingdom",
//   coverImage:
//     "https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg",
// };

// const {
//   title: firstTitle,
//   coverImage: firstCoverImage = "https://via.placeholder.com/640/480",
// } = firstBook;

// console.log(firstTitle); // The Last Kingdom
// console.log(firstCoverImage); // https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg

// const secondBook = {
//   title: "Сон смішної людини",
// };

// const {
//   title: secondTitle,
//   coverImage: secondCoverImage = "https://via.placeholder.com/640/480",
// } = secondBook;

// console.log(secondTitle); // Сон смішної людини
// console.log(secondCoverImage); // https://via.placeholder.com/640/480

//? Такий запис читається як «Створити змінну firstTitle, в яку помістити значення властивості title з об'єкта firstBook»

//TODO Деструктуризація в циклах
//? Перебираючи масив об'єктів циклом for...of, утворюються багаторазові звернення до властивостей об'єкта.

// const books = [
//   {
//     title: "The Last Kingdom",
//     author: "Bernard Cornwell",
//     rating: 8.38,
//   },
//   {
//     title: "На березі спокійних вод",
//     author: "Роберт Шеклі",
//     rating: 8.51,
//   },
// ];

// for (const book of books) {
//   console.log(book.title);
//   console.log(book.author);
//   console.log(book.rating);
// }

//* Для того, щоб скоротити кількість повторень, можна деструктуризувати властивості об'єкта у локальні змінні в тілі циклу.
// for (const book of books) {
//   const { title, author, rating } = book;

//   console.log(title);
//   console.log(author);
//   console.log(rating);
// }

//* Якщо в об'єкті небагато властивостей, можна виконати деструктуризацію безпосередньо у місці оголошення змінної book.
// for (const { title, author, rating } of books) {
//   console.log(title);
//   console.log(author);
//   console.log(rating);
// }

//TODO Глибока деструктуризація
//? Для деструктуризації властивостей вкладених об'єктів використовуються ті самі принципи, що й в трьох попередніх вправах.

// const user = {
//   name: "Jacques Gluke",
//   tag: "jgluke",
//   stats: {
//     followers: 5603,
//     views: 4827,
//     likes: 1308,
//   },
// };

// const {
//   name,
//   tag,
//   stats: { followers, views: userViews, likes: userLikes = 0 },
// } = user;

// console.log(name); // Jacques Gluke
// console.log(tag); // jgluke
// console.log(followers); // 5603
// console.log(userViews); // 4827
// console.log(userLikes); // 1308

//! Деструктуризація масивів
//? Деструктуризоване присвоювання можна використовувати і для масивів, але з деякими особливостями:
//*  - Замість фігурних дужок {} використовуються квадратні [].
//*  - Змінним, зазначеним у квадратних дужках [], будуть послідовно присвоюватися значення елементів масиву.

//* EXP 1 - Є масив кольорів, з якого потрібно отримати значення кожної складової кольору в окремих змінних.
// const rgb = [200, 255, 100];
// const [red, green, blue] = rgb;

// console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"

// Після ключового слова const або let ставимо квадратні дужки, як і у випадку з оголошенням масиву.
// Всередині дужок, через кому, вказуємо імена змінних, в які будуть поміщені значення масиву.

// Внаслідок такого запису будуть створені 3 змінні, і в них будуть поміщені елементи в нумерованому порядку - від 0 і до кінця масиву.

//? Під час деструктуризації масивів, значення змінної може присвоюватися після її оголошення. На практиці це рідко використовується.
// const rgb = [200, 255, 100];
// let red, green, blue;

// [red, green, blue] = rgb;

// console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"

//? Якщо змінних більше, ніж елементів масиву, їм буде присвоєно undefined, тому можна вказувати значення за замовчуванням.
// const rgb = [200, 100, 255];

// const [red, green, blue, alfa = 0.3] = rgb;

// console.log(`R:${red},G:${green},B:${blue},Alfa:${alfa}`); // "R:200,G:100,B:255,Alfa:0.3"

//? Іноді з масиву необхідно деструктуризувати тільки перші N елементів, а інші зберегти в одну змінну у вигляді масиву.
//? Деструктуруючи масив, можна розпакувати і присвоїти іншу частину елементів масиву змінної, використовуючи операцію ... (rest).
// const rgb = [200, 255, 100];

// const [red, ...colors] = rgb;

// console.log(red); // "200"
// console.log(colors); // [255, 100]

//? Елементи можна пропускати. Припустимо, з масиву rgb необхідно взяти тільки останнє значення. На практиці ця можливість рідко використовується.
// const rgb = [200, 100, 255];

// const [, , blue] = rgb;

// console.log(`Blue: ${blue}`); // "Blue: 255"

